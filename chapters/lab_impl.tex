\chapter{代理内核实验的参考实现}

在本章节，我们将给出移植K210后的代理内核实验的参考实现。
每个实验实现的阐述结构大致相同，
先从实验预期开始，描述实验的目标和预期效果。
然后我们会给出参考实现的代码和实现过程描述。
最后给出实验执行流程的总结。

\section{系统调用}

给定用户态应用user/app\_helloworld.c。

\begin{lstlisting}[caption={用户态应用app\_helloworld.c}, label={lst:app_helloworld}, language=C]
    #include "user_lib.h"

    int main(void) {
        printu("Hello world!\n");
        exit(0);
    }   
\end{lstlisting}

\subsection{实验预期}

实验的目标是PKE能够加载并成功运行它。
实验预期是应用可以打印出“Hello world!”，并正常退出。

\subsection{具体实现}

如上的用户态代码很简单，只有两行。第一行是用户态的打印函数printu()。
第二行是退出进程的函数exit()。
关于printu()和exit()函数的定义在user\_lib.c。
接下来我们看看这两个函数的具体实现：

\begin{lstlisting}[caption={printu与exit的实现}, label={lst:printu_exit}, language=C]
    int printu(const char *s, ...) {
        va_list vl;
        va_start(vl, s);
        char out[256];  // fixed buffer size.
        int res = vsnprintf(out, sizeof(out), s, vl);
        va_end(vl);
        const char *buf = out;
        size_t n = res < sizeof(out) ? res : sizeof(out);

        return do_user_call(SYS_user_print, (uint64) buf, n, 0, 0, 0, 0, 0);
    }

    int exit(int code) {
        return do_user_call(SYS_user_exit, code, 0, 0, 0, 0, 0, 0);
    }   
\end{lstlisting}

观察发现，printu()和exit()函数的实现都是简单处理了输入的参数，
然后就调用了do\_user\_call()函数。他们俩都是通过系统调用来获取自己所需的功能。
那么结论已经很明显，
我们只需要在PKE的内核代码中实现printu()和exit()的系统调用即可。

观察内核代码发现，printu()和exit()的系统调用都已经实现，
系统调用部分只有handle\_syscall()并未实现。该函数的功能是让用户进程的pc值增加4。
之所以增加4，是因为RISC-V的指令是32位的，32位代表着4个字节。
然后调用系统调用，最终将返回值保存在a0寄存器中。接下来我们给出它的实现代码。

\begin{lstlisting}[caption={handle\_syscall的实现}, label={lst:handle_syscall}, language=C]
static void handle_syscall(trapframe *tf) {
    tf->epc += 4;
    tf->regs.a0 = do_syscall(tf->regs.a0, tf->regs.a1,
                                tf->regs.a2, tf->regs.a3, 
                                tf->regs.a4, tf->regs.a5, 
                                tf->regs.a6, tf->regs.a7);
}
\end{lstlisting}

将实验要求实现后，我们可以在K210上运行实验代码，得到如下结果。

\begin{lstlisting}[caption={lab1实验结果}, label={lst:lab1_result}]
    [rustsbi] Version 0.1.0
    .______       __    __      _______.___________.  _______..______   __
    |   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
    |  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
    |      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
    |  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
    | _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
    
    [rustsbi] Platform: K210
    [rustsbi] misa: RV64ACDFIMSU
    [rustsbi] mideleg: 0x222
    [rustsbi] medeleg: 0x1ab
    [rustsbi] Kernel entry: 0x80020000
    Enter supervisor mode...
    
    Application program entry point (virtual address): 0x00000000800206b2
    
    Switch to user mode...
    
    Hello world!
    
    User exit with code:0.
    
    System is shutting down with exit code 0.
    
    [rustsbi] todo: shutdown all harts on k210; program halt
        
\end{lstlisting}

\section{异常处理}

给定用户态应用user/app\_illegal\_instruction.c

\begin{lstlisting}[caption={用户态应用app\_illegal\_instruction.c}, label={lst:app_illegal_instruction}, language=C]
    int main(void) {
        printu("Going to hack the system by running privilege instructions.\n");
        asm volatile("csrw sscratch, 0");
        exit(0);
    }
\end{lstlisting}

\subsection{实验预期}

用户态程序执行了非法指令csrw。
PKE应当能够捕获非法指令异常，并进行简单处理。

\subsection{实验分析}

由于RustSBI-K210支持包对K210进行了兼容性的处理。
K210实现的RISC-V指令集版本是1.9.1，而最新的RISC-V指令集版本是1.11.0。
为了能让K210能够运行高版本的RISC-V指令，
该支持包捕获了高版本指令产生的异常，然后将其转换为低版本的指令。
这种机制使得我们可以在K210上运行最新版的RISC-V指令。

为了保持这种兼容性，指令异常只能由M模式的RustSBI处理，
我们不能将指令异常托管给S模式的PKE。
所以此次实验，我们没有办法在PKE中完成，
只能交给RustSBI处理。
所幸，RustSBI已经实现了非法指令的捕获与处理，
当用户程序执行非法指令时，RustSBI会捕获异常，
并且产生panic，输出panic信息。这和原来实验的预期是一致的。

此次实验不需要我们改动PKE代码，就可以得到预期效果：

\begin{lstlisting}[caption={lab2实验结果}, label={lst:app_illegal_instruction_result}]
    [rustsbi] Version 0.1.0
    .______       __    __      _______.___________.  _______..______   __
    |   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
    |  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
    |      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
    |  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
    | _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
    
    [rustsbi] Platform: K210
    [rustsbi] misa: RV64ACDFIMSU
    [rustsbi] mideleg: 0x222
    [rustsbi] medeleg: 0x1ab
    [rustsbi] Kernel entry: 0x80020000
    Enter supervisor mode...
    
    Application program entry point (virtual address): 0x0000000080020788
    
    Switch to user mode...
    
    Going to hack the system by running privilege instructions.
    
    [rustsbi] panicked at 'invalid instruction, mepc: 0000000080020798, instruction: 14005073', platform/k210/src/main.rs:522:17
        
\end{lstlisting}

\section{定时器中断}

\subsection{实验预期}

\subsection{实验改进}

\subsection{具体实现}

\subsection{执行流程}

\section{虚拟地址和物理地址的转换}

\subsection{实验预期}

\subsection{具体实现}

\subsection{执行流程}

\section{基本的内存管理}

\subsection{实验预期}

\subsection{具体实现}

\subsection{执行流程}

\section{栈空间不足与缺页异常}
你好
\subsection{实验预期}

\subsection{具体实现}

\subsection{执行流程}

\section{创建子进程fork的实现}

\subsection{实验预期}

\subsection{兼容K210与改进}

\subsection{具体实现}

\subsection{执行流程}

\section{进程的控制权交接}

\subsection{实验预期}

\subsection{具体实现}

\subsection{执行流程}

\section{进程的时间片调度}

\subsection{实验预期}

\subsection{具体实现}

\subsection{执行流程}

\section{实验资料的编写及管理}

\subsection{实验指导书的编写}

\subsection{实验指导书的管理}

\subsection{对应代码库的管理}
你好
