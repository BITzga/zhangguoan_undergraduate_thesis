
\chapter{编译流程及内核启动流程改造}

\section{引入RustSBI}

\subsection{SBI背景与现状}

移植K210时，PKE需要依赖SBI（Supervisor Binary Interface）提供BOOTLOADER和RUNTIME功能，所以烧录内核时需要带上SBI固件。
通过调研发现，OpenSBI与RustSBI（用Rust语言实现的SBI）均按照SBI标准实现。这两种也是业内使用最多的开源SBI。
qemu就是用了OpenSBI为RISC-V提供了环境支持。
此外，RustSBI还对K210做了特殊支持。
所以目前暂定使用RustSBI当作SBI固件，为PKE提供BOOTLOADER功能和RUNTIME运行时服务。
移植过程中我们不需要关心RustSBI的具体实现，只需要根据SBI标准调用其接口即可。

除此之外，引入SBI，可以便于内核在其他板子上运行。
当更换板子时，不需要改变内核代码，只需要更改RustSBI的支持包，获取对应硬件平台的支持包即可。
这也简化了后续内核在其他芯片的移植工作。

\subsection{RustSBI的中断和异常委托}

\subsection{RustSBI提供bootLoader功能与运行时服务}

\subsection{使用RustSBI兼容K210旧版指令集}

RustSBI在K210兼容了高版本的指令。
K210实现的RISC-V指令集是1.9.1标准的。目前最新的特权级标准已经达到1.11。
如果我们的内核代码里有用到更高级的RISC-V汇编指令，可能会在K210上无法运行。
这种情况下，就要改动内核的代码，会带来许多工作量。
因此，使用RustSBI可以使我们免去处理RISC-V汇编版本的麻烦。

\section{编译流程改造}

\subsection{编译流程改造的背景}

\subsection{内存布局改造}
由于我们引入了RustSBI，RustSBI需要占用0x80000000-0x8001FFFF的物理内存空间。所以，内核的程序入口点由此发生了变化。我们需要修改内核lds文件，更改了程序的入口点以保证内核可以正常运行。

首先，我们现在mentry.S中加入以下两行代码，用以确保\_mentry是内核的程序入口点。

\begin{lstlisting}[caption={修改内核程序入口点}, label={lst:change_kernel_entry}]
    .globl _mentry
    .section .text.prologue, "ax"
    _mentry:
\end{lstlisting}

确定了内核的程序入口点，还需要把程序入口点的地址设置为0x80020000，这需要我们对内存布局进行改造。
修改BASE\_ADDRESS，赋值为0x80020000.并设置代码段的起始地址为BASE\_ADDRESS，自此，内存布局就修改完成了。

\begin{lstlisting}[caption={修改内存布局}, label={lst:change_memory_layout}]
    OUTPUT_ARCH(riscv)
    ENTRY(_mentry)
    BASE_ADDRESS = 0x80020000;
    SECTIONS
    {
      /*--------------------------------------------------------------------*/
      /* Code and read-only segment                                         */
      /*--------------------------------------------------------------------*/
    
      /* Begining of code and text segment, starts from DRAM_BASE to be effective before enabling paging */
      . = BASE_ADDRESS;
      
      /* text: Program code section */
      .text : 
      {
        stext = .;
        *(.text.prologue);
        *(.text .stub .text.* .gnu.linkonce.t.*);
        . = ALIGN(0x1000);
        ......
       }
    
\end{lstlisting}

\subsection{Makefile改造}

由于我们需要引入RustSBI，并需要将其打包进入内核。
除此之外，还需要将内核烧录到K210，并与K210进行串口通讯。
现有的Makefile并不支持这些工作。因此，我们需要修改MakeFile。

\begin{lstlisting}[caption={修改Makefile}, label={lst:change_makefile}]
    $(KERNEL_K210_TARGET): $(KERNEL_TEMP_TARGET) $(BOOTLOADER)
    $(COPY) $(BOOTLOADER) $@
    $(V)dd if=$(KERNEL_TEMP_TARGET) of=$@ bs=128K seek=1
\end{lstlisting}

整体的编译流程为：

1.打包内核

\begin{lstlisting}[caption={打包内核}, label={lst:pack_kernel}]
    $(KERNEL_K210_TARGET): $(KERNEL_TEMP_TARGET) $(BOOTLOADER)
    $(COPY) $(BOOTLOADER) $@
     $(V)dd if=$(KERNEL_TEMP_TARGET) of=$@ bs=128K seek=1
\end{lstlisting}


以上步骤是为了把rust-sbi.bin和pke.img打包成kernel.img。
bs=128k意味着输入/输出的block大小为128k，seek=1意味着跳过第零个block进行复制操作。
也就是说，内核镜像里第零个block存放着rust-sbi.bin，第一个block才开始存放pke.img。
128k对应着十六进制0x20000，也就是二进制的0010 0000 0000 0000 0000。

我们的kernel.img放置在0x80000000处，再加上以上原因，pke的地址自然就是0x8020000。
所以，我们需要在链接脚本kernel.lds里指定内核起始地址为0x8020000，这也相当于告诉SBI这是内核的起始地址。
当SBI在行使bootloader的功能时，会跳转到0x8020000，将控制权转接给内核。

2.烧录

用数据线将K210与上位机连接，再使用kflash，指定好相关参数即可完成烧录。

\begin{lstlisting}[caption={烧录}, label={lst:burn}]
    $(PYTHON) compile_tool/kflash.py -p $(PORT) -b 1500000 $(KERNEL_K210_TARGET)
\end{lstlisting}

3.运行minitem，与K210进行串口通讯

\begin{lstlisting}[caption={运行minitem}, label={lst:run_minitem}]
    $(TERM) --eol LF --dtr 0 --rts 0 --filter direct $(PORT) 115200
\end{lstlisting}

打开miniterm,接收K210的串口打印输出。

4.总结

最小可执行内核在K210的运行流程是：
指定内核起始地址->打包完整内核镜像->
烧录到flash->引导程序加载和运行RustSBI->
RustSBI运行并跳转到内核的指定地址->
RustSBI将控制权交接给内核->内核运行

\subsection{编译自动化脚本编写}

\section{内核启动流程改造}

\subsection{用户程序加载}

在原先pke的中，是通过调用spike接口，进而调用linux的文件系统接口来加载用户程序的。
而在K210上，我们没有spike的环境支持，不能直接调用spike接口。
因此，加载用户程序就需要自行实现文件系统，或者使用其他办法。

由于文件系统的实现较为繁琐，其工作量会阻塞这个移植进度。
因此，我们暂时不实现文件系统，而是采用获取用户程序地址，再加载的办法来实现这个需求。

具体的做法是：

\begin{enumerate}
    \item 将用户程序、内核和RustSBI一起编译打包到kernel.img
    \item 使用objdump命令查找到用户程序main函数的地址
    \item 得到地址以后，把地址的值赋值到内核加载用户程序处
\end{enumerate}

通过这种技术方案，我们可以用较低的开发成本实现用户程序加载。

\subsection{内核程序入口点修改}

由于RustSBI已经运行在M态，并且为我们提供了许多运行时服务。
有了RustSBI，在K210上，pke运行在M态会破坏RustSBI的设计，因此pke只需要运行在S态即可。

这样，我们就可以直接将pke的M态代码根据自身需求迁移到S态代码。
迁移完成后，需要更改内核程序入口点至S态入口

修改mentry.S文件，将call m\_start 替换成 call s\_start

\section{接口移植}

\subsection{接口移植的背景}
PKE已有代码对spike提供的HTIF（Host-Target InterFace）接口存在依赖。
当PKE需要打印字符串到屏幕、访问主机上的文件或设备时会调用HTIF相关接口。
PKE通过HTIF接口调用Linux对应接口，进而实现访问外部设备的功能。

如果需要在K210上维持和原先PKE在spike模拟器一样的环境。
K210板子要同时运行PKE和Linux两个内核程序，还要提供spike模拟器类似的与Linux访问的HTIF接口。
这样的移植方案的开发成本会很高。并且收益不大。

所以移植PKE到K210时，我们需要移除PKE对HTIF的依赖，自行实现其依赖功能，编写相关代码。
这样K210只需要运行一个内核程序（PKE）即可，移植工作的开发成本会很低。

\subsection{移植所需接口梳理}

\subsubsection{串口相关接口}
运行在K210上的PKE，需要使用串口接口来进行串口的访问。打印字符串到上位机。这样子才能方便我们进行实验验证，程序调试。
PKE原先并未实现串口功能，而是通过调用HTIF接口来使用串口功能。因此，我们需要自行实现串口功能。

\subsubsection{文件系统相关接口}

原先的PKE没有实现文件系统，而是通过调用HTIF接口来使用文件系统功能。
PKE在加载用户elf程序文件时，通过调用HTIF接口来访问用户程序文件，从而将用户程序加载到内存中。
最后再运行用户程序。

\subsubsection{Device Tree相关接口}

此接口的功能是用于读取设备树文件，以屏蔽SoC细节。

\subsubsection{shutdown接口}

供panic使用的接口，用于关闭设备。在内核panic时调用。PKE原先并未实现该功能，而是通过调用HTIF接口来实现。

\subsubsection{poweroff接口}

供panic使用的接口，用于关闭设备电源。在内核assert失败时使用。PKE原先并未实现该功能，而是通过调用HTIF接口来实现。

\subsubsection{定时器接口}

此接口用于PKE设置定时中断，读取时间。
PKE中是使用MMIO（memory mapping IO）来设置定时中断。
由于K210开发板此方面的资料较少，不确定K210是否支持此方式。
从减少开发成本的角度考虑，该接口使用SBI接口来实现的方案最低，可以免去查阅资料和测试的成本。
因此，该接口也需要我们进行移植。

\subsection{接口移植的技术方案}

\subsubsection{串口}

\subsubsection{文件系统相关接口}

\subsubsection{Device Tree相关接口}

\subsubsection{shutdown接口}

\subsubsection{poweroff接口}

\subsubsection{定时器接口}

\subsection{接口移植的具体实现}

\subsubsection{串口}

\subsubsection{文件系统相关接口}

\subsubsection{Device Tree相关接口}

\subsubsection{shutdown接口}

\subsubsection{poweroff接口}

\subsubsection{定时器接口}