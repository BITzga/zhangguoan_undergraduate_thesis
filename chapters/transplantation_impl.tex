% 第五章
\chapter{移植PKE的具体实现}

\section{引入RustSBI}

\subsection{SBI背景与现状}

移植K210时，PKE需要依赖SBI（Supervisor Binary Interface）提供Bootloader和RUNTIME功能，所以烧录内核时需要带上SBI固件。
通过调研发现，OpenSBI与RustSBI（用Rust语言实现的SBI）均按照SBI标准实现。这两种也是业内使用最多的开源SBI。
qemu就是用了OpenSBI为RISC-V提供了环境支持。
此外，RustSBI还对K210做了特殊支持。
所以目前暂定使用RustSBI当作SBI固件，为PKE提供Bootloader功能和RUNTIME运行时服务。
移植过程中我们不需要关心RustSBI的具体实现，只需要根据SBI标准调用其接口即可。

除此之外，引入SBI，可以便于内核在其他板子上运行。
当更换板子时，不需要改变内核代码，只需要更改RustSBI的支持包，获取对应硬件平台的支持包即可。
这也简化了后续内核在其他芯片的移植工作。

\subsection{RustSBI的中断和异常委托}

RustSBI在M模式下初始化时，会通过硬编码的方式将部分中断和异常委托给PKE。
而剩余部分则由RustSBI自行处理，例如指令异常的处理。

\begin{lstlisting}[caption={RustSBI的中断和异常委托}, label={lst:rustsbi_interrupt_and_exception}]
// 委托终端；把S的中断全部委托给S层
fn delegate_interrupt_exception() {
    use riscv::register::{medeleg, mideleg, mie};
    unsafe {
        mideleg::set_stimer();
        mideleg::set_ssoft();
        medeleg::set_instruction_misaligned();
        medeleg::set_breakpoint();
        medeleg::set_user_env_call();
        mie::set_msoft();
    }
}
\end{lstlisting}

由于需要兼容K210上的旧版RISC-V指令集，
RustSBI-K210实现无法将指令异常托管给S层的PKE。
所以我们不能轻易改动RustSBI-K210关于指令异常的逻辑。

\subsection{RustSBI提供Bootloader功能与运行时服务}

RustSBI在完成初始化工作后，会跳转的0x80020000处，
进入S模式，将控制权交给PKE。

除此之外，RustSBI实现了SBI标准的绝大部分要求，它可以提供运行时服务，
如SBI PUTCHAR，向串口输出信息、SBI SHUTDOWN，关闭所有硬件线程的运行。

\subsection{使用RustSBI兼容K210旧版指令集}

RustSBI在K210兼容了高版本的指令。
K210实现的RISC-V指令集是1.9.1标准的。目前最新的特权级标准已经达到1.11。
如果我们的内核代码里有用到更高级的RISC-V汇编指令，可能会在K210上无法运行。
这种情况下，就要改动内核的代码，会带来许多工作量。
因此，使用RustSBI可以使我们免去处理RISC-V汇编版本的麻烦。

\subsection{使用RustSBI兼容不同的RISC-V开发板}

RustSBI是SBI标准的Rust语言实现。
RustSBI-K210是RustSBI在K210上的具体实现。

\section{编译流程改造}

\subsection{编译流程改造的背景}

\subsection{内存布局改造}
由于我们引入了RustSBI，RustSBI需要占用0x80000000-0x8001FFFF的物理内存空间。所以，内核的程序入口点由此发生了变化。我们需要修改内核lds文件，更改了程序的入口点以保证内核可以正常运行。

首先，我们现在mentry.S中加入以下两行代码，用以确保\_mentry是内核的程序入口点。

\begin{lstlisting}[caption={修改内核程序入口点}, label={lst:change_kernel_entry}]
    .globl _mentry
    .section .text.prologue, "ax"
    _mentry:
\end{lstlisting}

确定了内核的程序入口点，还需要把程序入口点的地址设置为0x80020000，这需要我们对内存布局进行改造。
修改BASE\_ADDRESS，赋值为0x80020000.并设置代码段的起始地址为BASE\_ADDRESS，自此，内存布局就修改完成了。

\begin{lstlisting}[caption={修改内存布局}, label={lst:change_memory_layout}]
    OUTPUT_ARCH(riscv)
    ENTRY(_mentry)
    BASE_ADDRESS = 0x80020000;
    SECTIONS
    {
      /*--------------------------------------------------------------------*/
      /* Code and read-only segment                                         */
      /*--------------------------------------------------------------------*/
    
      /* Begining of code and text segment, starts from DRAM_BASE to be effective before enabling paging */
      . = BASE_ADDRESS;
      
      /* text: Program code section */
      .text : 
      {
        stext = .;
        *(.text.prologue);
        *(.text .stub .text.* .gnu.linkonce.t.*);
        . = ALIGN(0x1000);
        ......
       }
    
\end{lstlisting}

\subsection{Makefile改造}

由于我们需要引入RustSBI，并需要将其打包进入内核。
除此之外，还需要将内核烧录到K210，并与K210进行串口通讯。
现有的Makefile并不支持这些工作。因此，我们需要修改MakeFile。

\begin{lstlisting}[caption={修改Makefile}, label={lst:change_makefile}]
    $(KERNEL_K210_TARGET): $(KERNEL_TEMP_TARGET) $(BOOTLOADER)
    $(COPY) $(BOOTLOADER) $@
    $(V)dd if=$(KERNEL_TEMP_TARGET) of=$@ bs=128K seek=1
\end{lstlisting}

整体的编译流程为：

1.打包内核

\begin{lstlisting}[caption={打包内核}, label={lst:pack_kernel}]
    $(KERNEL_K210_TARGET): $(KERNEL_TEMP_TARGET) $(BOOTLOADER)
    $(COPY) $(BOOTLOADER) $@
     $(V)dd if=$(KERNEL_TEMP_TARGET) of=$@ bs=128K seek=1
\end{lstlisting}


以上步骤是为了把rust-sbi.bin和pke.img打包成kernel.img。
bs=128k意味着输入/输出的block大小为128k，seek=1意味着跳过第零个block进行复制操作。
也就是说，内核镜像里第零个block存放着rust-sbi.bin，第一个block才开始存放pke.img。
128k对应着十六进制0x20000，也就是二进制的0010 0000 0000 0000 0000。

我们的kernel.img放置在0x80000000处，再加上以上原因，pke的地址自然就是0x8020000。
所以，我们需要在链接脚本kernel.lds里指定内核起始地址为0x8020000，这也相当于告诉SBI这是内核的起始地址。
当SBI在行使Bootloader的功能时，会跳转到0x8020000，将控制权转接给内核。

2.烧录

用数据线将K210与上位机连接，再使用kflash，指定好相关参数即可完成烧录。

\begin{lstlisting}[caption={烧录}, label={lst:burn}]
    $(PYTHON) compile_tool/kflash.py -p $(PORT) -b 1500000 $(KERNEL_K210_TARGET)
\end{lstlisting}

3.运行minitem，与K210进行串口通讯

\begin{lstlisting}[caption={运行minitem}, label={lst:run_minitem}]
    $(TERM) --eol LF --dtr 0 --rts 0 --filter direct $(PORT) 115200
\end{lstlisting}

打开miniterm,接收K210的串口打印输出。

4.总结

最小可执行内核在K210的运行流程是：
指定内核起始地址->打包完整内核镜像->
烧录到flash->引导程序加载和运行RustSBI->
RustSBI运行并跳转到内核的指定地址->
RustSBI将控制权交接给内核->内核运行

\subsection{编译自动化脚本编写}

\section{内核启动流程改造}

\subsection{内核启动流程改造前后对比}

\subsection{内核程序入口点修改}

由于RustSBI已经运行在M态，并且为我们提供了许多运行时服务。
有了RustSBI，在K210上，pke运行在M态会破坏RustSBI的设计，因此pke只需要运行在S态即可。

这样，我们就可以直接将pke的M态代码根据自身需求迁移到S态代码。
迁移完成后，需要更改内核程序入口点至S态入口

修改mentry.S文件，将call m\_start 替换成 call s\_start

\subsection{内核初始化}

\section{驱动开发}

\subsection{串口驱动}

\subsection{时钟驱动}

\section{HTIF依赖移除及接口移植}

PKE已有代码对spike提供的HTIF（Host-Target InterFace）接口存在依赖。
当PKE需要打印字符串到屏幕、访问主机上的文件或设备时会调用HTIF相关接口。
PKE通过HTIF接口调用Linux对应接口，进而实现访问外部设备的功能。

如果需要在K210上维持和原先PKE在spike模拟器一样的环境。
K210板子要同时运行PKE和Linux两个内核程序，还要提供spike模拟器类似的与Linux访问的HTIF接口。
这样的移植方案的开发成本会很高。并且收益不大。

所以移植PKE到K210时，我们需要移除PKE对HTIF的依赖，自行实现其依赖功能，编写相关代码。
这样K210只需要运行一个内核程序（PKE）即可，移植工作的开发成本会很低。

\subsection{涉及接口梳理}

\subsubsection{串口相关接口}
运行在K210上的PKE，需要使用串口接口来进行串口的访问。打印字符串到上位机。这样子才能方便我们进行实验验证，程序调试。
PKE原先并未实现串口功能，而是通过调用HTIF接口来使用串口功能。因此，我们需要自行实现串口功能。

\subsubsection{文件系统相关接口}

原先的PKE没有实现文件系统，而是通过调用HTIF接口来使用文件系统功能。
PKE在加载用户elf程序文件时，通过调用HTIF接口来访问用户程序文件，从而将用户程序加载到内存中。
最后再运行用户程序。

\subsubsection{Device Tree相关接口}

此接口的功能是用于读取设备树文件，以屏蔽SoC细节。

\subsubsection{shutdown接口}

供panic使用的接口，用于关闭设备。在内核panic时调用。PKE原先并未实现该功能，而是通过调用HTIF接口来实现。

\subsubsection{poweroff接口}

供panic使用的接口，用于关闭设备电源。在内核assert失败时使用。PKE原先并未实现该功能，而是通过调用HTIF接口来实现。

\subsubsection{定时器接口}

此接口用于PKE设置定时中断，读取时间。
PKE中是使用MMIO（memory mapping IO）来设置定时中断。
由于K210开发板此方面的资料较少，不确定K210是否支持此方式。
从减少开发成本的角度考虑，该接口使用SBI接口来实现的方案最低，可以免去查阅资料和测试的成本。
因此，该接口也需要我们进行移植。

\subsection{接口移植的技术方案及实现}

\subsubsection{串口及格式化输出实现}

由于我们已经引入了RustSBI，我们很容易实现串口输出。
我们只需要调用SBI提供的串口服务即可。

\begin{lstlisting}[language=C, caption={串口实现代码}, label={lst:serial_output} ]
    uint64 SBI_CONSOLE_PUTCHAR = 1;
    uint64 sbi_call(uint64 sbi_type, uint64 arg0, uint64 arg1, uint64 arg2) {
    uint64 ret_val;
    __asm__ volatile (
    "mv x17, %[sbi_type]\n"
    "mv x10, %[arg0]\n"
    "mv x11, %[arg1]\n"
    "mv x12, %[arg2]\n"
    "ecall\n"
    "mv %[ret_val], x10"
    : [ret_val] "=r"(ret_val)
    : [sbi_type] "r"(sbi_type), [arg0] "r"(arg0), [arg1] "r"(arg1), [arg2] "r"(arg2)
    : "memory"
    );
        return ret_val;
    }

    void sbi_console_putchar(unsigned char ch) {
        sbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0);
    }
\end{lstlisting}

有了串口输出的方法，接下来我们需要格式化输出sprint.sprint定义在spike\_utils.c,接下来我们看看sprint的代码实现。

\begin{lstlisting}[language=C, caption={sprint实现代码}, label={lst:sprint} ]
    void sprint(char *buf, const char *fmt, ...) {
        va_list args;
        va_start(args, fmt);
        vsnprintf(buf, 1024, fmt, args);
        va_end(args);
    }
\end{lstlisting}

sprint函数的第一个参数对应了一个字符串的起始地址，第二个参数...代表可变参数。接下来我们点开vprintk的实现:

\begin{lstlisting}[language=C, caption={vprintk实现代码}, label={lst:vprintk} ]
    void vprintk(const char* s, va_list vl) {
        char out[256];
        int res = vsnprintf(out, sizeof(out), s, vl);
        //you need spike_file_init before this call
        spike_file_write(stderr, out, res < sizeof(out) ? res : sizeof(out));
    }
\end{lstlisting}

通过阅读代码发现，vsnprintf并没有将字符串真正输出到控制台。
而是根据原先的字符串和参数做字符串格式化，将最终结果保存在out数组中。

真正将字符串打印的函数调用是spike\_file\_write。
这个函数是调用了spike的接口，通过spike去调用Linux的字符串打印API。
所以我们需要在K210上实现串口输出，方案已经很明显，就是将vprintk函数中的spike\_file\_write函数替换成sbi\_console\_putchar实现的打印函数cputs。

\begin{lstlisting}[language=C, caption={vprintk改造代码}, label={lst:vprintk_dev} ]
    void vprintk(const char *s, va_list vl) {
        char out[256];
        int res = vsnprintf(out, sizeof(out), s, vl);
        cputs(out);
    }
    /* *
     * cputs- writes the string pointed by @str to stdout and
     * appends a newline character.
     * */
    int cputs(const char *str) {
        int cnt = 0;
        char c;
        while ((c = *str++) != '\0') {
            cputch(c, &cnt);
        }
        cputch('\n', &cnt);
        return cnt;
    }   
\end{lstlisting}

至此，我们完成了串口实现和格式化输出。通过在K210上验证，我们的sprint可以通过串口，在控制台上输出格式化的字符串。

\subsubsection{文件系统相关接口}

\subsubsection{Device Tree相关接口}

PKE运行在S态，设备树文件已经由M态的RustSBI读取并处理。因此PKE不需要读取和解析设备树文件。
所以，我们在移植时，只需要去除PKE读取DTB的代码即可。

\subsubsection{shutdown与poweroff接口}

内核在编码调试过程中，需要借助一些方法来判断变量值是否符合预期，如assert方法。
如果不符合预期需要打印错误信息，并且让内核panic。
那么panic在pke上是如何实现的呢？我们可以阅读pke实现panic的代码。

\begin{lstlisting}[language=C, caption={panic实现代码}, label={lst:panic} ]
    void do_panic(const char *s, ...) {
        va_list vl;
        va_start(vl, s);
        sprint(s, vl);
        shutdown(-1);
        va_end(vl);
    }
    
    void shutdown(int code) {
      sprint("System is shutting down with exit code %d.\n", code);
      frontend_syscall(HTIFSYS_exit, code, 0, 0, 0, 0, 0, 0);
      while (1)
        ;
    }    
\end{lstlisting}

通过观察我们可以发现，panic的调用链路是:

do\_panic->shutdown->frontend\_syscall

最终panic是通过frontend\_syscall调用spike提供的接口实现的。
既然是需要调用spike的HTIF，与spike的HTIF具有依赖关系，那么我们移植的时候就需要去除相关依赖，自行实现do\_panic函数。

通过观察panic和poweroff功能，很容易发现，他们都是打印报错信息，然后终止了硬件线程（hart）。
那么我们可以通过调用SBI的shutdown接口来实现这两个接口，打印报错以后以后，终止所有的hart。

\subsubsection{定时器接口}

参考ucore通过调用SBI接口来实现定时器接口。

\section{用户程序加载}

\subsection{单个进程加载}

在原先PKE的中，是通过调用spike接口，进而调用linux的文件系统接口来加载用户程序的。
而在K210上，我们没有spike的环境支持，不能直接调用spike接口。
因此，加载用户程序就需要自行实现文件系统，或者使用其他办法。

由于文件系统的实现较为繁琐，其工作量会阻塞这个移植进度。
因此，我们暂时不实现文件系统，而是采用获取用户程序地址，再加载的办法来实现这个需求。

具体的做法是：

\begin{enumerate}
    \item 将用户程序、内核和RustSBI一起编译打包到kernel.img
    \item 使用objdump命令查找到用户程序main函数的地址
    \item 得到地址以后，把地址的值赋值到内核加载用户程序处
\end{enumerate}

通过这种技术方案，我们可以用较低的开发成本实现用户程序加载。

\subsection{开启虚拟内存空间后用户进程的加载}
你好

\subsection{多进程支持}
你好