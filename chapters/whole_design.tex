% 第三章

\chapter{移植PKE的总体设计}

\section{移植PKE到K210的背景}

接下来，本文将通过阐述PKE移植前的开发环境与移植后的预期收益，
介绍移植PKE到K210的背景。

\subsection{PKE移植前开发环境介绍}

PKE移植前的运行环境主要分为两种，分别是硬件环境和模拟器环境。
他们的总体情况是一致的，但还是有一些细微的区别。

在模拟器环境上，PKE运行在spike模拟的RISC-V 64位机器上。
而spike模拟器则运行在宿主机Ubuntu上。
当PKE需要使用外部设备的I/O功能时，
PKE就通过调用spike提供的HTIF接口，
让Ubuntu提供I/O功能，以访问宿主机上的外设资源。

如下图，本文给出了模拟器环境的系统架构。

\begin{figure}[htbp]
    \vspace{13pt} % 调整图片与上文的垂直距离
    \centering
    \includegraphics[width=0.9\textwidth]{images/spike_structure.png}
    \caption{模拟器环境架构}\label{模拟器环境架构} % label 用来在文中索引
\end{figure}

在硬件环境上，我们的系统是运行在PYNQ-Z2开发板上。
PYNQ-Z2开发板是Xilinx公司的一款开发板，
它具有丰富的外设资源、强大的性能。此外，它还兼容了Arduino和树莓派接口。

PYNQ-Z2搭载了FPGA系统和ARM处理器。\cite{2019Research}FPGA可以烧录RISC-V CPU软核，
ARM硬核可以运行Ubuntu操作系统。我们的代理内核PKE运行在RISC-V CPU软核上，
而提供外设功能的Ubuntu则运行在ARM硬核上。
PKE和Ubuntu之间是通过riscv-fesvr通信的。
riscv-fesvr是PYNQ开发板上的重要工具，没有它，PKE就无法调用ARM上的Ubuntu I/O接口。
riscv-fesvr通过共享内存的方式，接收PKE的请求，使用ARM端的资源，并向PKE提供资源与功能。

如下图，本文给出了硬件环境的系统架构。

\begin{figure}[htbp]
    \vspace{13pt} % 调整图片与上文的垂直距离
    \centering
    \includegraphics[width=0.9\textwidth]{images/pke_hardware_env.drawio.png}
    \caption{硬件环境架构}\label{硬件环境架构} % label 用来在文中索引
\end{figure}

\subsection{PKE移植前开发环境的优缺点}

在上一小节，本文简单介绍了PKE在移植前的开发环境。
在本小节，本文会客观分析PKE原先的物理开发环境的优点与缺点。

在原先的物理环境中，代理内核的系统是运行在PYNQ-Z2板子上的。
PYNQ-Z2拥有FPGA和ARM物理核。FPGA可以让开发者烧录RISC-V CPU软核，
然后让开发者在RISC-V CPU软核上运行PKE。
ARM硬核可以运行Ubuntu操作系统，提供I/O功能。\cite{1996Computer}

从不同的开发方向看。
如果开发者是在开发CPU软核，
需要快速验证FPGA上的CPU软核并进行迭代。
这种物理环境允许开发者不实现CPU涉及I/O的功能，
便于开发快速开发和验证CPU软核。

如果开发者是在开发或学习操作系统，这种开发环境反而对开发者不利。
一个原因是提供这种物理环境的开发板PYNQ-Z2价格昂贵，成本高昂。
其价格已经快要接近一台PC机的价格。
此开发板在某网购平台上的均价已达到三千余元。
这对入门级操作系统学习者购买学习资料、课程实验教学都是不利的。

另一个原因环境配置繁琐，开发者需要在PYNQ上烧录RISC-V CPU软核，
还需要在ARM核上部署Ubuntu。
除此之外，还需要在ARM核上部署riscv-fesvr，让PKE与Ubuntu通信。
这种开发环境的部署成本和学习成本是很高的，
这对于刚入门操作系统实验学习的开发者是不利的。

总而言之，PKE系统的物理环境价格昂贵、成本高昂、搭建成本高、学习成本高，
不利于学习者入门，也不利于大规模展开实验教学。\cite{2021Reform}
这些是PKE移植前的物理环境的痛点。
为了解决这些痛点，本文提出了将PKE移植到K210上的方案。将在下一小节阐述该方案的收益。

\subsection{PKE移植后的预期收益}

上一小节我们提到，PKE原先的物理环境有许多缺点。
这些缺点不利于学习者入门、也不利于大规模展开实验教学。
因此，我们计划将PKE移植到K210物理环境上。
PKE移植后，我们将拥有如下收益:

\begin{enumerate}
    \item 成本低廉
    
    K210板子价格低廉。
    一块不带外设的普通K210 SoC的市场价格只需要一百多元。
    与动辄就要三千余元的PYNQ-Z2相比，K210的经济成本仅仅是PYNQ-Z2的三十分之一。
    这非常有利于我们开展大规模的物理环境实验教学。
    也非常有利于入门学习者购买资料进行学习。

    \item 物理环境搭建成本低
    
    在K210上，我们不再像从前在PYNQ-Z2那样烧录RISC-V CPU软核，
    也不需要在PYNQ-Z2的ARM核上加载运行Ubuntu。
    由于K210带有RISC-V 64位CPU，我们只需要在K210上烧录并运行PKE即可。
    这使得我们的物理环境搭建成本变得极低。

    \item 环境搭建学习成本低
    
    移植PKE到K210后，我们可以使用配置好的docker环境包、
    编写Makefile将编译与烧录流程变得自动化。
    由于不再需要在PYNQ-Z2上烧录RISC-V CPU软核，
    也不需要在PYNQ-Z2的ARM核上加载运行Ubuntu。
    我们的环境搭建是自动化的。环境搭建的学习成本也是很低的。

\end{enumerate}


\section{移植PKE的目标与需求分析}

\begin{enumerate}

    \item 降低PKE在物理环境的开发成本
    
    移植PKE的首要目标，是降低PKE在物理环境的开发成本。
    这其中包括降低购买硬件资源的经济成本，也包括降低环境搭建的学习成本。
    这将有利于我们后续开展大规模的物理环境实验。
    也会降低PKE实验的学习门槛。

    \item 用户态程序无感知
    
    PKE在移植K210的过程中，会有一定程度的内核态代码修改。
    从实验迁移的角度来看，这些内核态代码的修改不应该让用户态程序感知到。
    否则，我们很有可能还要修改用户态程序，以适配修改过的PKE。
    这不仅会增加我们移植PKE的开发成本，也会增加后续实验操作者的学习成本。

    \item 减少实验操作者对移植的感知
    
    PKE移植后产生的内核态代码修改，应该尽可能地不让实验操作者感知。
    修改过后的PKE，应该对实验操作者提供与原先一致的接口，
    以降低移植对实验操作者的影响。

    \item 提高实验操作者的开发效率
    
    移植后的PKE需要能做到提高实验操作者的开发效率，
    如环境搭建更加简化、编译流程和烧录流程更加自动化、
    调试过程更加清晰化、提供给实验者的API更加易用。
    
    \item 降低PKE后续移植的成本

    经过改造后的PKE，后续移植到其他RISC-V开发板时，它的移植成本应该降低。
    也就是说，我们的移植工作应该是可复用的。
    只要是将PKE移植到其他的RISC-V开发板，我们都应该尽可能地减少对内核代码的改动。
    
\end{enumerate}

\section{移植K210前PKE的总体设计}

在PKE移植前，我们对PKE的架构、各主要功能模块、执行流程进行了梳理。
本节将对这些梳理好的内容进行介绍。
这将便于读者理解我们后续的移植工作。

\subsection{系统架构}

\begin{figure}[htbp]
    \vspace{13pt} % 调整图片与上文的垂直距离
    \centering
    \includegraphics[width=0.9\textwidth]{images/before_sys_struct.drawio.png}
    \caption{移植前PKE的系统架构}\label{移植前PKE的系统架构} % label 用来在文中索引
\end{figure}

如架构图所示，硬件之上，我们的系统分为三种特权模式。
分别为机器模式（M-mode）、监管者模式（S-mode）、用户模式（U-mode）。

代理内核PKE可以运行在两种特权模式。
这两种特权模式分别是机器模式和监管者模式（S-mode）。

PKE运行在机器模式时，主要负责内核的初始化工作，
如读取并解析设备树文件、将时钟初始化、将HTIF接口初始化、
将异常与中断委托寄存器初始化、设置内核入口点、设置中断向量表、加载用户进程。
除此之外，处于M模式的PKE还负责部分中断/异常的拦截与处理。
只要是没有委托给S模式的中断与异常，都会交给M模式的PKE进行拦截与处理。

PKE运行在监管者模式时，主要负责物理内存的管理、
虚拟内存的管理、物理内存与虚拟内存地址的转换、
进程的调度、部分中断与异常的拦截与处理。

用户程序则运行在用户态。在PKE启动时，
用户程序会被PKE加载到内存中，
然后加载成进程，最终由PKE运行。
用户程序的特权级是最低的，拥有的权限最少。
PKE会为用户程序提供系统调用接口，在保证权限安全的情况下，
为用户程序提供所需功能。

\subsection{主要功能模块介绍}

PKE主要分为五个功能模块，
分别是初始化模块、
中断/异常的拦截与处理模块、
内存管理模块、进程管理模块、
spike相关模块。

初始化模块运行在M模式，主要负责读取并解析设备树文件、将时钟初始化、将HTIF接口初始化、
将异常与中断委托寄存器初始化、设置内核入口点、设置中断向量表、加载用户进程等。

中断/异常的拦截与处理模块在M模式和S模式都存在。
该模块主要负责中断/异常的拦截与处理。
mideleg和medeleg寄存器分别决定了中断和异常在哪个层进行处理。
除此之外，mtvec和stvec决定了中断向量表的入口点。
当发生异常或中断时，RISC-V CPU会将异常或中断交给对应特权级的层处理。
处理异常或中断的层根据中断向量表选择对应的处理程序，处理异常或中断。

内存管理模块运行在S模式，该模块完成了物理内存的初始化、
分页模式的开启、虚拟地址空间的管理、
内存的基本分配和回收、虚实地址之间的转换。

进程管理模块运行在S模式，该模块负责用户进程的加载、
子进程的创建、进程的控制权交接、进程的时间片调度。

spike相关模块在M模式和S模式都存在，
该模块负责HTIF的初始化、与Host机器上的Ubuntu通信、
向PKE提供I/O功能。

\subsection{执行流程}

PKE首先需要在M模式下进行初始化，在完成中断/异常的委托初始化后、
PKE会进而设置sie寄存器来确定M模式下要处理的中断，
之后PKE会设置mtvec寄存器来确定中断向量表的入口点。
除此之外，很有可能对定时器中断进行了设置。
最后PKE会从M模式进入S模式。

进入S模式后，PKE会对物理内存进行初始化，进而开启SV39分页机制，
接着会对虚拟地址空间进行初始化，将虚拟地址和物理地址进行映射。
进程模块会加载用户进程，并将其设置为当前进程。
接着跳转到U模式，开始执行用户进程。

用户进程在运行时，如果发生了系统调用、中断或异常，
CPU的执行会跳转到特权级更高的模式的PKE内核，如M模式、S模式的PKE。
接下来PKE，将会为用户进程提供系统调用功能、处理异常或中断的功能。


\section{移植PKE到K210的技术方案}

为了解决PKE目前存在的痛点，我们在本小节提供移植PKE到K210的技术方案。

首先，我们需要引入RustSBI。
RustSBI会读取并解析设备树文件，这可以帮助我们屏蔽K210 SoC的细节。
此外，RustSBI还提供了一些二进制接口，如串口输出、定时器设置等，
这可以减少我们移植过程中的开发成本。

第二，我们需要改造编译流程。由于我们引入了RustSBI，
所以在内核编译打包时，我们需要将RustSBI一起打包进入内核的img文件中。
这需要我们改造现有的编译流程，编写Makefile以完成我们所需编译与烧录功能。

第三，我们需要改造内核的启动流程。由于RustSBI占据了M模式，
我们的PKE内核只能运行在S模式上，
所以我们需要将原先M模式的启动逻辑迁移到S模式上。
这就需要我们改造PKE的启动流程。

第四，我们需要开发驱动程序。
虽然RustSBI为我们提供了一些二进制接口，如串口输出、定时器设置等。
但这些接口只提供了最简单的功能，如输出单个字符。
我们需要在此之上进行封装并形成驱动程序，以便后续移植时使用。

第五，我们需要将HTIF依赖移除然后进行接口移植。
对于移植K210后的PKE而言，HTIF接口已经失去作用，并且会干扰PKE的运行。
所以我们需要移除PKE中的HTIF依赖。再根据我们的需求，对依赖的接口进行移植。

最后，我们需要对用户程序进行加载。由于开发成本的原因，我们暂时不打算实现文件系统。
原先的PKE是通过文件系统加载用户程序的，我们需要改造成通过内存加载。
通过调研发现，ucore在未实现文件系统时，
是通过同时编译打包内核程序和用户程序到内核文件中，并记录用户程序的起始地址和长度。
最终根据记录值在内存中加载用户程序。
PKE参考了这种方式，实现了类似于ucore的内存加载用户进程的方式。

\section{移植K210后PKE的总体设计}

\subsection{系统架构}

\begin{figure}[h]
    \vspace{13pt} % 调整图片与上文的垂直距离
    \centering
    \includegraphics[width=0.9\textwidth]{images/after_sys_struct.drawio.png}
    \caption{移植后PKE的系统架构}\label{移植后PKE的系统架构} % label 用来在文中索引
\end{figure}

\subsection{主要功能模块介绍}

移植完成后的PKE的主要功能模块如下：
串口与定时器的驱动模块、K210支持模块、初始化模块、
内存管理模块、中断或异常处理模块、进程管理模块。

与原先的PKE相比，它多出了K210支持模块，驱动模块，
它减少了spike相关模块。

K210支持模块是对驱动程序的封装，它为PKE提供了简单易用的库函数。

驱动模块处理了串口、定时器的驱动，让PKE的其他功能模块变得简单。

由于我们移除了HTIF依赖，我们不再需要spike提供的HTIF功能，因此spike相关模块也会被移除。

其他模块与移植前的PKE相比，功能大致相同，这里就不再赘述了。

PKE之外还有烧录工具K-Flash、串口通讯工具minitem。
K-Flash是一个Python程序，它帮助我们将打包好的内核烧录到K210。\cite{2002Flash}
minitem是一个串口通讯工具，它可以接收K210串口输出信息，
并将信息显示在我们的上位机上。


\subsection{执行流程}



RustSBI首先需要在M模式下进行初始化，在完成中断/异常的委托初始化后、
设备树文件加载和解析后，还有其他初始化工作以后。
RustSBI会从M模式进入S模式。跳转到PKE的入口点，将控制权交给PKE。

进入S模式后，PKE会对物理内存进行初始化，进而开启SV39分页机制，
接着会对虚拟地址空间进行初始化，将虚拟地址和物理地址进行映射。
进程模块会通过内存的方式加载用户进程，并将其设置为当前进程。
接着跳转到U模式，开始执行用户进程。

用户进程在运行时，如果发生了系统调用、中断或异常，
CPU的执行会跳转模式的S模式的PKE或M模式的RustSBI。
接下来PKE或RustSBI，将会为用户进程提供系统调用功能、处理异常或中断的功能。